---
layout: post
title: PWN knowledge 
date: 2022-9-2
description: Some knowledge I have learnt in the CTF competition
tags: ctf
categories: 
giscus_comments: true
related_posts: false
---

# protection

## ASLR:

```
+-----------------+                    +----------------+  
|      ...        |                    |      ...       |        
+-----------------+                    |----------------|  
|      stack      |                    |----------------|
+-----------------+                    |      stack     |
|-----------------|                    +----------------+
|      heap       |                    |      heap      |
|                 |                    |                |
+-----------------+                    +----------------+
```

For each time we load the binary, the stack, heap, libc is allocated differently.
The way to deal with this is to leak ONE address, then we get the base and get everything.
This is beacuse although they are placed differently in the memory space, the offset between each label is fixed, in other words, the things inside each chunk will not change.

## Pie: (Position Independent Executable)

    0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
    0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
    0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
    0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
    0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try

    It is actual the binary version of ASLR, it only change the binary section. Therefore, the way to defeat it is also the same with defeating ASLR

    gdb: (if we want to set an break with pie on)
        pie b *0x116f
        pie run

## Canary:
    Only check when the function returns, we can change it, but just need to change it back once the function returns.

# FastBinDoubleFree
form a  1->2->1 structure
```
                    |--------
                    v       |
main arena -> 1 -> 2 -> 1 --
```

change the content of 1 which means the fd of 1


chunk 1 is being malloc() and content of chunk 1 is changed to something else.
SO,
```
|   chunk 1     |
| 0xdeadbeef    |
main arena -> 2 -> 1 -> 0xdeadbeef
```

```
malloc(0x10)
main arena -> 1 -> 0xdeadbeef
|   chunk 2     |
|   ????        |
```

```
malloc(0x10)
main arena -> 0xdeadbeef
|   chunk 1     |
|   0xdeadbeef  |
```

```python
chunk = malloc(0x10)
print('%p',chunk)
# will print out the content inside address 0xdeadbeef
```
*** need to change the content to match, and flag PRE_INUSE, so, set a 0x21 value