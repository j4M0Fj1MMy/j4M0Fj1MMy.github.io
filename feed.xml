<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://j4m0fj1mmy.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://j4m0fj1mmy.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-11-03T19:29:00+00:00</updated><id>https://j4m0fj1mmy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Decompiler</title><link href="https://j4m0fj1mmy.github.io/blog/2023/decompiler/" rel="alternate" type="text/html" title="Decompiler"/><published>2023-09-04T00:00:00+00:00</published><updated>2023-09-04T00:00:00+00:00</updated><id>https://j4m0fj1mmy.github.io/blog/2023/decompiler</id><content type="html" xml:base="https://j4m0fj1mmy.github.io/blog/2023/decompiler/"><![CDATA[<h1 id="decompilation-of-llvm-ir-to-c">Decompilation of LLVM IR to C</h1> <h2 id="introduction">Introduction</h2> <p>In our reverse engineering lab, we utilize a binary lifter to produce simplified LLVM intermediate representation (IR) from the binary files. This IR serves as a crucial step in understanding the behavior of the program. To enhance the reverse engineering process, we aim to link (decompile) the LLVM IR to C code, allowing us to grasp the programâ€™s functionality more quickly. Although the decompilation process may introduce inaccuracies, it is essential to have the ability to refer back to the precise and accurate LLVM IR representation.</p> <h2 id="ast-generation">AST Generation</h2> <p>To achieve the decompilation of LLVM IR to C, we leverage the Clang and LLVM APIs to load the Abstract Syntax Tree (AST) of the LLVM IR. It will then be transformed to the Clang AST. All subsequent simplification processes and transformations will be performed on the Clang AST.</p> <h2 id="optimization">Optimization</h2> <p>During the decompilation process, several code simplification techniques are applied to enhance the readability of the decompiled code. These techniques include dead code elimination, elimination of equivalent if-else conditions, and various other optimizations that make the decompiled code more concise and understandable.</p> <h2 id="challenges-encountered">Challenges Encountered</h2> <p>Throughout the decompilation process, we faced several challenges that required careful consideration and problem-solving. The following are some of the notable challenges we encountered:</p> <h3 id="refinement-of-the-condition-inside-if-and-while-statement-takes-a-very-long-time">Refinement of the condition inside if and while statement takes a very long time</h3> <p>One specific challenge we faced involved dealing with the if condition. When such a condition is long, it is hard to simplify the whole condition at once. Decompiling nested conditions inside if statements can significantly slow down the process. We encountered cases where handling complex conditions inside if and while statements took a considerable amount of time to refine and optimize.</p> <pre><code class="language-C">bool x = true;
if ((!0 &amp;&amp; x == 1) || (1 &amp;&amp; x == 0)) printf("foo");
if ((x == 1) || (x == 0)) printf("foo");
if ((1)) printf("foo");
printf("foo");
</code></pre> <h3 id="how-to-optimize-the-clang-ast">How to optimize the Clang AST</h3> <ul> <li>Declare an ASTVisitor that inherits the <code class="language-plaintext highlighter-rouge">RecursiveASTVisitor</code></li> <li>Declare your own <code class="language-plaintext highlighter-rouge">visitxxxx</code> function that overrides the orginal ones</li> <li>Use the <code class="language-plaintext highlighter-rouge">TraverseDecl</code> to run those function</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyASTVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RecursiveASTVisitor</span><span class="o">&lt;</span><span class="n">MyASTVisitor</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">bool</span> <span class="n">VisitStmt</span><span class="p">(</span><span class="n">Stmt</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MyASTConsumer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ASTConsumer</span>
<span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">MyASTConsumer</span><span class="p">()</span><span class="o">:</span> <span class="n">Visitor</span><span class="p">()</span> <span class="p">{}</span><span class="c1">//initialize MyASTVisitor</span>
        
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HandleTopLevelDecl</span><span class="p">(</span><span class="n">DeclGroupRef</span> <span class="n">DR</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">DeclGroupRef</span><span class="o">::</span><span class="n">iterator</span> <span class="n">b</span> <span class="o">=</span> <span class="n">DR</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">e</span> <span class="o">=</span> <span class="n">DR</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Travel each function declaration using MyASTVisitor</span>
                <span class="n">Visitor</span><span class="p">.</span><span class="n">TraverseDecl</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">MyASTVisitor</span> <span class="n">Visitor</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="interesting-things-when-decompilation-is-too-good">Interesting things when decompilation is too good.</h2> <p>When the decompilation result is too optimized, redundant code can be removed, resulting in a decompiled code that is even simpler than the original source code. This can be an interesting outcome, showcasing the power of optimization techniques employed during the decompilation process.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the source code</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nl">start:</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="k">goto</span> <span class="n">start</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="k">goto</span> <span class="n">start</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the optimized decompilation result</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">arg3</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">2UL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">3UL</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="separate-function-decompilation">Separate function decompilation</h2> <p>To streamline the decompilation process and eliminate unwanted results, we found it beneficial to decompile each function separately. This approach allows us to focus on individual functions, speeding up the decompilation process and reducing the impact of slow-down caused by nested conditions inside if statements.</p> <p>Please note that while the decompilation process may introduce some inaccuracies, the availability of the original LLVM IR allows us to refer back to the precise representation when necessary.</p>]]></content><author><name></name></author><category term="sample-posts"/><category term="binary"/><summary type="html"><![CDATA[binary -> llvm -> C]]></summary></entry><entry><title type="html">Type Inference</title><link href="https://j4m0fj1mmy.github.io/blog/2023/type-inference/" rel="alternate" type="text/html" title="Type Inference"/><published>2023-07-15T00:00:00+00:00</published><updated>2023-07-15T00:00:00+00:00</updated><id>https://j4m0fj1mmy.github.io/blog/2023/type-inference</id><content type="html" xml:base="https://j4m0fj1mmy.github.io/blog/2023/type-inference/"><![CDATA[<p>This is an experiment on variable type prediction base on a autoencoder model approach</p> <h3 id="treating-code-as-a-language">Treating code as a language</h3> <blockquote> <p>If we treat code as a language, then we can use large language model to model the problem and therefore make prediction base on patterns. Indeed, there are research stating that code does have the property of our languages.</p> </blockquote> <h3 id="decompiler-of-choice">Decompiler of choice</h3> <blockquote> <p>The author of the original paper was doing their research with IDA. While other decopmilers are also possible, they found that Ghidra is not very good at the decompilation, which confuese the learning process and made poor results.</p> </blockquote> <h3 id="other-research">Other research</h3> <blockquote> <p>Another paper points out that the problem of Ghidra can be solved with an stright-forward workaround. And they claimed that using Ghidra as a decompilation tool also provides similar result.</p> </blockquote>]]></content><author><name></name></author><category term="sample-posts"/><category term="binary"/><summary type="html"><![CDATA[a autoencoder approach in recovering lost variable type information]]></summary></entry></feed>