<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://j4m0fj1mmy.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://j4m0fj1mmy.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-11-06T18:00:44+00:00</updated><id>https://j4m0fj1mmy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Decompiler</title><link href="https://j4m0fj1mmy.github.io/blog/2023/decompiler/" rel="alternate" type="text/html" title="Decompiler"/><published>2023-09-04T00:00:00+00:00</published><updated>2023-09-04T00:00:00+00:00</updated><id>https://j4m0fj1mmy.github.io/blog/2023/decompiler</id><content type="html" xml:base="https://j4m0fj1mmy.github.io/blog/2023/decompiler/"><![CDATA[<h1 id="decompilation-of-llvm-ir-to-c">Decompilation of LLVM IR to C</h1> <h2 id="introduction">Introduction</h2> <p>In our reverse engineering lab, we utilize a binary lifter to produce simplified LLVM intermediate representation (IR) from the binary files. This IR serves as a crucial step in understanding the behavior of the program. To enhance the reverse engineering process, we aim to link (decompile) the LLVM IR to C code, allowing us to grasp the program’s functionality more quickly. Although the decompilation process may introduce inaccuracies, it is essential to have the ability to refer back to the precise and accurate LLVM IR representation.</p> <p>My responsibilities included developing, integrating, testing, debugging, and maintaining the software to ensure seamless compatibility with the binary lifter. I also set up unit test cases, documented files, and conducted thorough case studies to evaluate the product’s speed, correctness, and handling of crash cases.</p> <h2 id="ast-generation">AST Generation</h2> <p>To achieve the decompilation of LLVM IR to C, we leverage the Clang and LLVM APIs to load the Abstract Syntax Tree (AST) of the LLVM IR. It will then be transformed to the Clang AST. All subsequent simplification processes and transformations will be performed on the Clang AST.</p> <h2 id="optimization">Optimization</h2> <p>During the decompilation process, several code simplification techniques are applied to enhance the readability of the decompiled code. These techniques include dead code elimination, elimination of equivalent if-else conditions, and various other optimizations that make the decompiled code more concise and understandable.</p> <h2 id="challenges-encountered">Challenges Encountered</h2> <p>Throughout the decompilation process, we faced several challenges that required careful consideration and problem-solving. The following are some of the notable challenges we encountered:</p> <h3 id="refinement-of-the-condition-inside-if-and-while-statement-takes-a-very-long-time">Refinement of the condition inside if and while statement takes a very long time</h3> <p>One specific challenge we faced involved dealing with the if condition. When such a condition is long, it is hard to simplify the whole condition at once. Decompiling nested conditions inside if statements can significantly slow down the process. We encountered cases where handling complex conditions inside if and while statements took a considerable amount of time to refine and optimize.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">"foo"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">"foo"</span><span class="p">);</span>
<span class="k">if</span> <span class="p">((</span><span class="mi">1</span><span class="p">))</span> <span class="n">printf</span><span class="p">(</span><span class="s">"foo"</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"foo"</span><span class="p">);</span>
</code></pre></div></div> <h3 id="how-to-optimize-the-clang-ast">How to optimize the Clang AST</h3> <ul> <li>Declare an ASTVisitor that inherits the <code class="language-plaintext highlighter-rouge">RecursiveASTVisitor</code></li> <li>Declare your own <code class="language-plaintext highlighter-rouge">visitxxxx</code> function that overrides the orginal ones</li> <li>Use the <code class="language-plaintext highlighter-rouge">TraverseDecl</code> to run those function</li> </ul> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyASTVisitor</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RecursiveASTVisitor</span><span class="o">&lt;</span><span class="n">MyASTVisitor</span><span class="o">&gt;</span><span class="p">{</span>
    <span class="nl">public:</span>
        <span class="kt">bool</span> <span class="n">VisitStmt</span><span class="p">(</span><span class="n">Stmt</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MyASTConsumer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ASTConsumer</span>
<span class="p">{</span>
    <span class="nl">public:</span>
        <span class="n">MyASTConsumer</span><span class="p">()</span><span class="o">:</span> <span class="n">Visitor</span><span class="p">()</span> <span class="p">{}</span><span class="c1">//initialize MyASTVisitor</span>
        
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">HandleTopLevelDecl</span><span class="p">(</span><span class="n">DeclGroupRef</span> <span class="n">DR</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">DeclGroupRef</span><span class="o">::</span><span class="n">iterator</span> <span class="n">b</span> <span class="o">=</span> <span class="n">DR</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">e</span> <span class="o">=</span> <span class="n">DR</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">b</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Travel each function declaration using MyASTVisitor</span>
                <span class="n">Visitor</span><span class="p">.</span><span class="n">TraverseDecl</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">MyASTVisitor</span> <span class="n">Visitor</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="interesting-things-when-decompilation-is-too-good">Interesting things when decompilation is too good.</h2> <p>When the decompilation result is too optimized, redundant code can be removed, resulting in a decompiled code that is even simpler than the original source code. This can be an interesting outcome, showcasing the power of optimization techniques employed during the decompilation process.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the source code</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="nl">start:</span>
    <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="k">goto</span> <span class="n">start</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="k">goto</span> <span class="n">start</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// the optimized decompilation result</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">arg3</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1UL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">2UL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">3UL</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0UL</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="separate-function-decompilation">Separate function decompilation</h2> <p>To streamline the decompilation process and eliminate unwanted results, we found it beneficial to decompile each function separately. This approach allows us to focus on individual functions, speeding up the decompilation process and reducing the impact of slow-down caused by nested conditions inside if statements.</p> <p>Please note that while the decompilation process may introduce some inaccuracies, the availability of the original LLVM IR allows us to refer back to the precise representation when necessary.</p>]]></content><author><name></name></author><category term="binary"/><summary type="html"><![CDATA[binary -> llvm -> C]]></summary></entry><entry><title type="html">Type Inference</title><link href="https://j4m0fj1mmy.github.io/blog/2023/type-inference/" rel="alternate" type="text/html" title="Type Inference"/><published>2023-07-01T00:00:00+00:00</published><updated>2023-07-01T00:00:00+00:00</updated><id>https://j4m0fj1mmy.github.io/blog/2023/type-inference</id><content type="html" xml:base="https://j4m0fj1mmy.github.io/blog/2023/type-inference/"><![CDATA[<h1 id="intro">Intro</h1> <p>In the variable name and type inference model, it utilizes a Transformer autoencoder. This model treats C code as a language and predicts missing types and names from stripped binaries in an LLM methodology. My role involved conducting academic research, performing experiments, and developing a prototype pipeline for input data and output predictions. Furthermore, I proposed the use of a type dictionary as a novel approach to enhance accuracy in type inference. This is based on <a href="https://cmustrudel.github.io/papers/ChenDIRTY2022.pdf">this</a> paper.</p> <ul> <li>Operating System: Linux</li> <li>Developemnt Environment: Ghidra, PyTorch</li> <li>Languages: shell, python</li> </ul> <h3 id="treating-code-as-a-language">Treating code as a language</h3> <p>If we treat code as a language, we can leverage a large language model to understand its patterns and make predictions. Several research studies have shown that code exhibits properties similar to natural languages.</p> <h3 id="decompiler-of-choice">Decompiler of choice</h3> <p>In the referenced paper, the authors conducted their research using IDA as the decompiler. While there are other decompilers available, they found that Ghidra’s decompilation results were not satisfactory, which hindered the learning process and yielded poor results.</p> <h3 id="decompiling-of-struct">Decompiling of struct</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//original code</span>

<span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// stack layout:</span>
<span class="c1">// [xxx][padding][yyyy]</span>
<span class="kt">char</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// decompiled code</span>

<span class="kt">void</span> <span class="nf">fun</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// stack layout:</span>
<span class="c1">// [xxxx][yyyy]</span>
<span class="kt">char</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="other-research">Other research</h3> <p>Another research paper suggests that the limitations of Ghidra can be overcome with a straightforward workaround. They claim that using Ghidra as a decompilation tool can also yield similar results.</p> <h3 id="the-work">The work</h3> <p>I used Ghidra since it is open-source, and I am more familiar with it.</p>]]></content><author><name></name></author><category term="ML,"/><category term="data"/><summary type="html"><![CDATA[an autoencoder in recovering lost variable type information]]></summary></entry><entry><title type="html">PWN knowledge</title><link href="https://j4m0fj1mmy.github.io/blog/2022/ctf/" rel="alternate" type="text/html" title="PWN knowledge"/><published>2022-09-02T00:00:00+00:00</published><updated>2022-09-02T00:00:00+00:00</updated><id>https://j4m0fj1mmy.github.io/blog/2022/ctf</id><content type="html" xml:base="https://j4m0fj1mmy.github.io/blog/2022/ctf/"><![CDATA[<h1 id="protection">protection</h1> <h2 id="aslr">ASLR:</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+-----------------+                    +----------------+  
|      ...        |                    |      ...       |        
+-----------------+                    |----------------|  
|      stack      |                    |----------------|
+-----------------+                    |      stack     |
|-----------------|                    +----------------+
|      heap       |                    |      heap      |
|                 |                    |                |
+-----------------+                    +----------------+
</code></pre></div></div> <p>For each time we load the binary, the stack, heap, libc is allocated differently. The way to deal with this is to leak ONE address, then we get the base and get everything. This is beacuse although they are placed differently in the memory space, the offset between each label is fixed, in other words, the things inside each chunk will not change.</p> <h2 id="pie-position-independent-executable">Pie: (Position Independent Executable)</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x0000000000400000 0x0000000000401000 0x0000000000000000 r-- /tmp/try
0x0000000000401000 0x0000000000402000 0x0000000000001000 r-x /tmp/try
0x0000000000402000 0x0000000000403000 0x0000000000002000 r-- /tmp/try
0x0000000000403000 0x0000000000404000 0x0000000000002000 r-- /tmp/try
0x0000000000404000 0x0000000000405000 0x0000000000003000 rw- /tmp/try

It is actual the binary version of ASLR, it only change the binary section. Therefore, the way to defeat it is also the same with defeating ASLR

gdb: (if we want to set an break with pie on)
    pie b *0x116f
    pie run
</code></pre></div></div> <h2 id="canary">Canary:</h2> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Only check when the function returns, we can change it, but just need to change it back once the function returns.
</code></pre></div></div> <h1 id="fastbindoublefree">FastBinDoubleFree</h1> <p>form a 1-&gt;2-&gt;1 structure</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    |--------
                    v       |
main arena -&gt; 1 -&gt; 2 -&gt; 1 --
</code></pre></div></div> <p>change the content of 1 which means the fd of 1</p> <p>chunk 1 is being malloc() and content of chunk 1 is changed to something else. SO,</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|   chunk 1     |
| 0xdeadbeef    |
main arena -&gt; 2 -&gt; 1 -&gt; 0xdeadbeef
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>malloc(0x10)
main arena -&gt; 1 -&gt; 0xdeadbeef
|   chunk 2     |
|   ????        |
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>malloc(0x10)
main arena -&gt; 0xdeadbeef
|   chunk 1     |
|   0xdeadbeef  |
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">chunk</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="mh">0x10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">'</span><span class="s">%p</span><span class="sh">'</span><span class="p">,</span><span class="n">chunk</span><span class="p">)</span>
<span class="c1"># will print out the content inside address 0xdeadbeef
</span></code></pre></div></div> <p>*** need to change the content to match, and flag PRE_INUSE, so, set a 0x21 value</p>]]></content><author><name></name></author><category term="ctf"/><summary type="html"><![CDATA[Some knowledge I have learnt in the CTF competition]]></summary></entry></feed>