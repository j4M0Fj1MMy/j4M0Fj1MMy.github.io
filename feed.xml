<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://j4m0fj1mmy.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://j4m0fj1mmy.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-11-03T05:31:26+00:00</updated><id>https://j4m0fj1mmy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Decompiler</title><link href="https://j4m0fj1mmy.github.io/blog/2023/decompiler/" rel="alternate" type="text/html" title="Decompiler"/><published>2023-09-04T00:00:00+00:00</published><updated>2023-09-04T00:00:00+00:00</updated><id>https://j4m0fj1mmy.github.io/blog/2023/decompiler</id><content type="html" xml:base="https://j4m0fj1mmy.github.io/blog/2023/decompiler/"><![CDATA[<h1 id="a-no-go-to-decompilation-of-llvm-ir">A no go-to decompilation of llvm IR</h1> <blockquote> <p>First, the binary was passed to our lab’s binary lifter. This produces simplified llvm intermediate representation. To enhance the reverse engineering process, we want to link(decompile) the llvm to C so that we understand the behaviour of the program faster. Even though the decompilation is inaccuarate at some point, we want to still be able to go back and look at the exact accurate llvm.</p> </blockquote> <h4 id="ast-generation">AST generation</h4> <blockquote> <p>With the clang and llvm API, the AST of the llvm is loaded. All simplification processes will be done on this AST.</p> </blockquote> <h3 id="optimization">Optimization</h3> <blockquote> <p>Many code simplification techiniques can be applied to make the decompiled code simplier to read. For example, dead code elimination, eliminate equivalent if-else condition, etc…</p> </blockquote> <h3 id="severel-problems-encountered">Severel problems encountered</h3> <h4 id="llvm-metadata">llvm metadata</h4> <blockquote> <p>missing metadata will result in failing checking conditions and crashing the program. So make sure the llvm metadata is provided and accurate.</p> </blockquote> <h4 id="different-bit-length-of-interger-literal-128bit-vs-64-bits">different bit length of interger literal, (128bit vs 64 bits)</h4> <blockquote> <p>Decompiler attempted to upcast a long long into 128 bit, and clang doesn’t support it…</p> </blockquote> <h4 id="invalid-z3-operation">Invalid z3 operation</h4> <blockquote> <p>some undefined operation are generated in the binary lifting stage</p> </blockquote>]]></content><author><name></name></author><category term="sample-posts"/><category term="binary"/><summary type="html"><![CDATA[binary -> llvm -> C]]></summary></entry><entry><title type="html">Type Inference</title><link href="https://j4m0fj1mmy.github.io/blog/2023/type-inference/" rel="alternate" type="text/html" title="Type Inference"/><published>2023-07-15T00:00:00+00:00</published><updated>2023-07-15T00:00:00+00:00</updated><id>https://j4m0fj1mmy.github.io/blog/2023/type-inference</id><content type="html" xml:base="https://j4m0fj1mmy.github.io/blog/2023/type-inference/"><![CDATA[<p>This is an experiment on variable type prediction base on a autoencoder model approach</p> <h3 id="treating-code-as-a-language">Treating code as a language</h3> <blockquote> <p>If we treat code as a language, then we can use large language model to model the problem and therefore make prediction base on patterns. Indeed, there are research stating that code does have the property of our languages.</p> </blockquote> <h3 id="decompiler-of-choice">Decompiler of choice</h3> <blockquote> <p>The author of the original paper was doing their research with IDA. While other decopmilers are also possible, they found that Ghidra is not very good at the decompilation, which confuese the learning process and made poor results.</p> </blockquote> <h3 id="other-research">Other research</h3> <blockquote> <p>Another paper points out that the problem of Ghidra can be solved with an stright-forward workaround. And they claimed that using Ghidra as a decompilation tool also provides similar result.</p> </blockquote>]]></content><author><name></name></author><category term="sample-posts"/><category term="binary"/><summary type="html"><![CDATA[a autoencoder approach in recovering lost variable type information]]></summary></entry></feed>